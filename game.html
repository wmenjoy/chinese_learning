<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>成语填字游戏</title>
    <style>
        .game-container {
            margin: 20px auto;
            max-width: 1200px;
            text-align: center;
        }

        .grid-container {
            display: inline-block;
            margin: 20px;
            overflow-x: auto;
            max-width: 100%;
            padding: 20px;
        }

        .grid-row {
            display: flex;
            justify-content: center;
            min-height: 40px; /* 确保即使没有内容也保持行高 */
        }

        .grid-cell {
            width: 35px;
            height: 35px;
            border: 1px solid #ccc;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 1px;
            font-size: 18px;
            cursor: pointer;
            background-color: white;
            user-select: none; /* 防止文字被选中 */
        }

        .grid-cell.empty {
            background-color: #f0f0f0;
        }

        .grid-cell.selected {
            background-color: #e6f3ff;
            border-color: #1890ff;
        }

        .controls {
            margin: 20px;
            display: flex;
            justify-content: center;
            gap: 10px;
            align-items: center;
        }

        button {
            padding: 8px 16px;
            margin: 0 5px;
            cursor: pointer;
            border: none;
            background-color: #1890ff;
            color: white;
            border-radius: 4px;
        }

        button:hover {
            background-color: #40a9ff;
        }

        .input-area {
            margin: 20px;
            display: flex;
            justify-content: center;
            gap: 10px;
            align-items: center;
        }

        #charInput {
            width: 40px;
            height: 40px;
            font-size: 20px;
            text-align: center;
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        #message {
            height: 24px;
            color: #666;
            margin: 10px 0;
        }

        select {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }

        @media (max-width: 768px) {
            .grid-cell {
                width: 30px;
                height: 30px;
                font-size: 16px;
            }
        }

        /* 添加动画效果 */
        .grid-cell {
            transition: all 0.3s ease;
        }

        .correct-answer {
            animation: correctAnswer 0.5s ease;
        }

        @keyframes correctAnswer {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        /* 添加游戏完成效果 */
        .game-complete {
            animation: gameComplete 1s ease infinite;
        }

        @keyframes gameComplete {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>成语填字游戏</h1>
        <div class="controls">
            <label for="idiomCount">选择成语数量：</label>
            <select id="idiomCount">
                <option value="10">10个</option>
                <option value="15">15个</option>
                <option value="20">20个</option>
                <option value="25">25个</option>
                <option value="30">30个</option>
            </select>
            <button onclick="startNewGame()">开始游戏</button>
        </div>
        <div class="grid-container" id="gridContainer"></div>
        <div class="input-area">
            <input type="text" 
                   id="charInput" 
                   maxlength="1" 
                   placeholder="字"
                   onkeypress="handleKeyPress(event)" />
            <button onclick="submitCharacter()">确认</button>
        </div>
        <div id="message"></div>
    </div>

    <script>
        // 这里添加游戏的核心逻辑
        class ChineseIdiomGame {
            constructor() {
                this.grid = [];
                this.positions = new Map();
                this.solution = new Map();
                this.selectedCell = null;
                this.idioms = [];
            }

            async loadIdioms() {
                try {
                    const response = await fetch('/Users/liujinliang/workspace/trae_code/chinese-xinhua/data/idiom.json');
                    this.idioms = await response.json();
                } catch (error) {
                    console.error('加载成语失败:', error);
                    // 使用示例成语作为备选
                    this.idioms = [
                        { "word": "望梅止渴" }, { "word": "一帆风顺" },
                        { "word": "顺水推舟" }, { "word": "舟车劳顿" },
                        { "word": "顿开茅塞" }, { "word": "塞翁失马" },
                        { "word": "马到成功" }, { "word": "功成名就" },
                        { "word": "就地正法" }, { "word": "法力无边" },
                        { "word": "边塞江南" }, { "word": "南辕北辙" },
                        { "word": "辙印斑斑" }, { "word": "斑驳陆离" },
                        { "word": "离乡背井" }, { "word": "井底之蛙" },
                        { "word": "蛙鸣蝉噪" }, { "word": "噪音扰民" },
                        { "word": "民不聊生" }, { "word": "生机勃勃" },
                        { "word": "勃然大怒" }, { "word": "怒发冲冠" },
                        { "word": "冠冕堂皇" }, { "word": "皇天后土" },
                        { "word": "土崩瓦解" }, { "word": "解甲归田" },
                        { "word": "田园风光" }, { "word": "光明磊落" },
                        { "word": "落叶归根" }, { "word": "根深蒂固" }
                    ];
                }
            }

            async setupGame(numIdioms) {
                if (this.idioms.length === 0) {
                    await this.loadIdioms();
                }

                const maxSize = Math.ceil(Math.sqrt(numIdioms * 16));
                this.grid = Array(maxSize).fill().map(() => Array(maxSize).fill(''));
                
                const selectedIdioms = this.getRandomIdioms(numIdioms);
                const center = Math.floor(maxSize / 2);

                // 放置第一个成语（横向）
                const firstIdiom = selectedIdioms[0].word;
                for (let i = 0; i < firstIdiom.length; i++) {
                    this.grid[center][center + i] = firstIdiom[i];
                    this.positions.set(`${center},${center + i}`, firstIdiom[i]);
                }

                // 放置第二个成语（纵向）
                const secondIdiom = selectedIdioms[1].word;
                for (let i = 0; i < secondIdiom.length; i++) {
                    if (secondIdiom[i] === this.grid[center][center]) {
                        for (let j = 0; j < secondIdiom.length; j++) {
                            const row = center - i + j;
                            this.grid[row][center] = secondIdiom[j];
                            this.positions.set(`${row},${center}`, secondIdiom[j]);
                        }
                        break;
                    }
                }

                const placedIdioms = [firstIdiom, secondIdiom];
                let isHorizontal = true;

                // 放置剩余成语
                for (let i = 2; i < selectedIdioms.length; i++) {
                    const idiom = selectedIdioms[i].word;
                    if (this.placeIdiomWithDirection(idiom, placedIdioms, isHorizontal)) {
                        placedIdioms.push(idiom);
                        isHorizontal = !isHorizontal;
                    }
                }

                this.solution = new Map(this.positions);
                this.trimGrid();
                this.removeRandomChars(0.4);
                return this.renderGrid();
            }

            getRandomIdioms(count) {
                const shuffled = [...this.idioms].sort(() => 0.5 - Math.random());
                return shuffled.slice(0, count);
            }

            placeIdiomWithDirection(idiom, placedIdioms, preferHorizontal) {
                for (const placed of placedIdioms) {
                    for (const char of idiom) {
                        if (placed.includes(char)) {
                            if (preferHorizontal) {
                                if (this.tryPlaceHorizontal(idiom, char) || 
                                    this.tryPlaceVertical(idiom, char)) {
                                    return true;
                                }
                            } else {
                                if (this.tryPlaceVertical(idiom, char) || 
                                    this.tryPlaceHorizontal(idiom, char)) {
                                    return true;
                                }
                            }
                        }
                    }
                }
                return false;
            }

            tryPlaceHorizontal(idiom, char) {
                const positions = this.findCharPositions(char);
                for (const [row, col] of positions) {
                    if (this.canPlaceHorizontal(idiom, row, col)) {
                        const idx = idiom.indexOf(char);
                        const startCol = col - idx;
                        
                        let hasCross = false;
                        for (let i = 0; i < idiom.length; i++) {
                            if (i !== idx && this.hasVerticalConnection(row, startCol + i)) {
                                hasCross = true;
                                break;
                            }
                        }
                        
                        if (hasCross || positions.length === 0) {
                            for (let i = 0; i < idiom.length; i++) {
                                this.grid[row][startCol + i] = idiom[i];
                                this.positions.set(`${row},${startCol + i}`, idiom[i]);
                            }
                            return true;
                        }
                    }
                }
                return false;
            }

            tryPlaceVertical(idiom, char) {
                const positions = this.findCharPositions(char);
                for (const [row, col] of positions) {
                    if (this.canPlaceVertical(idiom, row, col)) {
                        const idx = idiom.indexOf(char);
                        const startRow = row - idx;
                        
                        let hasCross = false;
                        for (let i = 0; i < idiom.length; i++) {
                            if (i !== idx && this.hasHorizontalConnection(startRow + i, col)) {
                                hasCross = true;
                                break;
                            }
                        }
                        
                        if (hasCross || positions.length === 0) {
                            for (let i = 0; i < idiom.length; i++) {
                                this.grid[startRow + i][col] = idiom[i];
                                this.positions.set(`${startRow + i},${col}`, idiom[i]);
                            }
                            return true;
                        }
                    }
                }
                return false;
            }

            findCharPositions(char) {
                const positions = [];
                this.positions.forEach((value, key) => {
                    if (value === char) {
                        const [row, col] = key.split(',').map(Number);
                        positions.push([row, col]);
                    }
                });
                return positions;
            }

            canPlaceHorizontal(idiom, row, col) {
                const idx = idiom.indexOf(this.grid[row][col]);
                const startCol = col - idx;
                
                for (let i = 0; i < idiom.length; i++) {
                    const currentCol = startCol + i;
                    if (currentCol < 0 || currentCol >= this.grid[0].length) return false;
                    if (this.grid[row][currentCol] && this.grid[row][currentCol] !== idiom[i]) return false;
                }
                return true;
            }

            canPlaceVertical(idiom, row, col) {
                const idx = idiom.indexOf(this.grid[row][col]);
                const startRow = row - idx;
                
                for (let i = 0; i < idiom.length; i++) {
                    const currentRow = startRow + i;
                    if (currentRow < 0 || currentRow >= this.grid.length) return false;
                    if (this.grid[currentRow][col] && this.grid[currentRow][col] !== idiom[i]) return false;
                }
                return true;
            }

            hasVerticalConnection(row, col) {
                return (this.grid[row - 1]?.[col] || this.grid[row + 1]?.[col]);
            }

            hasHorizontalConnection(row, col) {
                return (this.grid[row][col - 1] || this.grid[row][col + 1]);
            }

            trimGrid() {
                let minRow = this.grid.length, maxRow = 0;
                let minCol = this.grid[0].length, maxCol = 0;

                this.positions.forEach((_, key) => {
                    const [row, col] = key.split(',').map(Number);
                    minRow = Math.min(minRow, row);
                    maxRow = Math.max(maxRow, row);
                    minCol = Math.min(minCol, col);
                    maxCol = Math.max(maxCol, col);
                });

                this.grid = this.grid
                    .slice(minRow, maxRow + 1)
                    .map(row => row.slice(minCol, maxCol + 1));

                const newPositions = new Map();
                this.positions.forEach((value, key) => {
                    const [row, col] = key.split(',').map(Number);
                    newPositions.set(`${row - minRow},${col - minCol}`, value);
                });
                this.positions = newPositions;

                const newSolution = new Map();
                this.solution.forEach((value, key) => {
                    const [row, col] = key.split(',').map(Number);
                    newSolution.set(`${row - minRow},${col - minCol}`, value);
                });
                this.solution = newSolution;
            }

            removeRandomChars(percentage = 0.4) {
                const positions = Array.from(this.positions.keys());
                const numToRemove = Math.floor(positions.length * percentage);
                const positionsToRemove = positions
                    .sort(() => 0.5 - Math.random())
                    .slice(0, numToRemove);

                for (const pos of positionsToRemove) {
                    const [row, col] = pos.split(',').map(Number);
                    this.grid[row][col] = '';
                    this.positions.delete(pos);
                }
            }

            makeGuess(row, col, char) {
                const key = `${row},${col}`;
                if (this.solution.has(key) && this.solution.get(key) === char) {
                    this.grid[row][col] = char;
                    this.positions.set(key, char);
                    return true;
                }
                return false;
            }

            isComplete() {
                return this.positions.size === this.solution.size;
            }

            renderGrid() {
                return this.grid;
            }
        }

        // 全局变量
        let game = new ChineseIdiomGame();
        let selectedCell = null;

        // 开始新游戏
        async function startNewGame() {
            try {
                const numIdioms = parseInt(document.getElementById('idiomCount').value);
                game = new ChineseIdiomGame();
                const grid = await game.setupGame(numIdioms);
                if (grid && grid.length > 0) {
                    renderGameGrid(grid);
                    document.getElementById('message').textContent = '';
                }
            } catch (error) {
                console.error('启动游戏失败:', error);
                document.getElementById('message').textContent = '启动游戏失败，请重试';
            }
        }

        // 渲染游戏网格
        function renderGameGrid(grid) {
            const container = document.getElementById('gridContainer');
            container.innerHTML = '';
            
            grid.forEach((row, i) => {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'grid-row';
                
                row.forEach((cell, j) => {
                    const cellDiv = document.createElement('div');
                    cellDiv.className = 'grid-cell' + (cell ? '' : ' empty');
                    cellDiv.textContent = cell;
                    cellDiv.dataset.row = i;
                    cellDiv.dataset.col = j;
                    cellDiv.onclick = () => selectCell(cellDiv);
                    rowDiv.appendChild(cellDiv);
                });
                
                container.appendChild(rowDiv);
            });
        }

        // 选择单元格
        function selectCell(cell) {
            if (selectedCell) {
                selectedCell.classList.remove('selected');
            }
            cell.classList.add('selected');
            selectedCell = cell;
            document.getElementById('charInput').focus();
        }

        // 处理键盘事件
        function handleKeyPress(event) {
            if (event.key === 'Enter') {
                submitCharacter();
            }
        }

        // 提交字符
        function submitCharacter() {
            if (!selectedCell) {
                document.getElementById('message').textContent = '请先选择一个格子！';
                return;
            }

            const char = document.getElementById('charInput').value;
            if (!char) {
                document.getElementById('message').textContent = '请输入一个汉字！';
                return;
            }

            const row = parseInt(selectedCell.dataset.row);
            const col = parseInt(selectedCell.dataset.col);

            if (game.makeGuess(row, col, char)) {
                selectedCell.textContent = char;
                selectedCell.classList.remove('empty');
                selectedCell.classList.add('correct-answer');
                setTimeout(() => {
                    selectedCell.classList.remove('correct-answer');
                }, 500);
                document.getElementById('message').textContent = '填写正确！';
                
                if (game.isComplete()) {
                    document.getElementById('message').textContent = '恭喜你完成游戏！';
                    document.getElementById('gridContainer').classList.add('game-complete');
                }
            } else {
                document.getElementById('message').textContent = '填写错误，请重试！';
            }

            document.getElementById('charInput').value = '';
        }

        // 页面加载完成后初始化游戏
        document.addEventListener('DOMContentLoaded', () => {
            startNewGame();
        });
    </script>
</body>
</html>